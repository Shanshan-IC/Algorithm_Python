/*
位运算的加法
XOR
x	y	output
0	0	0
0	1	1
1	0	1
1	1	0

AND
x	y	output
0	0	0
0	1	0
1	0	0
1	1	1

5的二进制是101，17的二进制10001。
还是试着把计算分成三步：第一步各位相加但不计进位，得到的结果是10100
（最后一位两个数都是1，相加的结果是二进制的10。这一步不计进位，因此结果仍然是0）；
第二步记下进位。在这个例子中只在最后一位相加时产生一个进位，结果是二进制的10；
第三步把前两步的结果相加，得到的结果是10110，正好是22。


然后对x和y进行^位运算，得出没有加进位的和。
最后将所得的和当做新的x，所得的进位往左移一位(第零位的进位输入为0)当做新的y，
继续做上面的步骤，直到进位为0，此时x中保存的就是我们要求的x和y的和了。
*/

int add(int a, int b) {
　　int sum = a;
　　int carry = b;
　　while(carry)
　　{
　　　　int tmps = sum;
　　　　sum = tmps ^ carry;
　　　　carry = (tmps & carry) << 1;
　　}
　　return sum;
}

/*
减法：用的是补法
对减数取反然后加1，第二步将第一步所得值和被减数相加。
*/

int sub(int a, int b) {
    int neg = add(~a, 1);
    return add(a, neg(b));
}

/*
乘法
 　　111        7
　　 101        5
=====
       111
    0 0 0
 1 1 1
=====
100011     （35)
我们求乘法时，首先b的第一位跟a相乘，然后第二位为0，第三位相乘。
我们现在不从乘法的角度考虑，从加法考虑。
从b的第0位开始，如果第0位为1，则加上a（111），
接着第2位，第二位为0，不会加0000，第3次为1，加上11100.
b每向右移一位，a的值就要向左移动。
*/

int multiple(int a, int b) {
    int res = 0;
    while (b) {
        if (b & 1)
            ans = add(ans, a);
        a <<= 1;
        b >>= 1;
    }
}

/*
除法
除法就是由乘法的过程逆推，依次减掉（如果x够减的）y^(2^31),y^(2^30),...y^8,y^4,y^2,y^1。减掉相应数量的y就在结果加上相应的数量。
*/

int Pos_div(int x,int y)
{
    int ans=0;
    for(int i=31;i>=0;i--)
    {
        // //比较x是否大于y的(1<<i)次方，避免将x与(y<<i)比较，因为不确定y的(1<<i)次方是否溢出
        if( (x>>i) >=y )
        {
            ans+=(1<<i);
            x-= (y<<i);
        }
    }
    return ans;
}
